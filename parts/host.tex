\chapter {Hosting Environment}

The host is responsible for providing a state in which the plugin can be loaded,
unloaded and execute properly, a hosting environment. This of course includes
loading/unloading, restarting and shutdown of plugins, as well as initialization
of any data that may be used by the plugins themselves etc. Though the
compilation pass used to instrument the code should ideally be done by the host
itself, this policy and its implications, along with the pass itself is
described later in Chapter [ref].

The host is also responsible for keeping track of plugin resources and providing
an API to allocate, access and free these. This includes usage of standard
memory-allocation functions such as \texttt{malloc} and \texttt{new}, keeping
track of file descriptors etc. Associating these resources with a specific
plugin instance prevents resource leaking after the instance has been shut down.

Even though instrumented plugin code is considered \emph{trusted}, certain
operations, such as integer divisions aren't checked. Thus it's still possible
for plugins to raise signals in some environments for certain operations, such
as division by zero. Though this particular case could have been dealt with by
instrumenting every single divide instruction, it's easier and more effective to
have a signal handler to catch these types of errors, which trigger hardware
interrupts and have no additional overhead when used correctly. Apart from
raising these signals which can be caught by the host, the instrumentation pass
is responsible for generating instrumented code that aborts before (if) any
code which would have behaved maliciously or otherwise incorrect executes.

The hosting environment includes external functions available to the plugin,
including, not only the host's plugin API but also library functions in the C
standard library and any system-specific functions such as the POSIX API. For
instance, if a plugin raises the POSIX signal \texttt{SIGKILL}, the signal can
not be blocked or ignored by the program, forcing it to abort.[ref] External
functions, including plugin APIs are covered further in Chapter [ref].


\section {Plugin Types}

\subsection {Continuously-Running Plugins}

Plugins running on its own, doing its thing. Naturally takes a 1-to-1 mapping?

\subsection {Event-Based}

Plugins respond to events, such as audio-buffer callbacks. This can take the
form of tasks, where ยง


\section {Resource Limits}

Blah blah, too much memory, using too much cpu, not responding fast enough (tick
takes forever). TODO


\section {Global Initialization}

Init shadow mem etc.


\section {Plugin Startup}

How load plugin? How load new instances. What are? dlls. etc?


\section {Plugin Switching}

Thread-pool stuff.


\section {Error Recovery}

Ideally a plugin instance should shut down gracefully when misbehaving.
Allocated resources, such as memory or file descriptors, should be deallocated
or closed. These resources need to be tracked, even for the case where a plugin
doesn't per-se misbehave. Even if a plugin exits properly, but haven't for
instance closed file descriptors or \texttt{free}'d all allocated memory, there
would be resource/memory leaks, potentially quite severe.

The requirements for properly sandboxed plugins are more strict than that
however. A malicious plugin can call any external functions with completely
arbitrary arguments. This includes double-\texttt{free}'ing previously
allocated memory, a bug which can lead to serious memory corruption for the
entire process from which it is not able to recover.

This provides a clear protection domain. Any function calls external to the
module must be individually examined, and all arguments sanity checked.
\texttt{div} for instance can't expect a non-zero divisor. It also means that
no external function call can expect a following call with certain arguments;
\texttt{malloc} can't expect a matching \texttt{free}, \texttt{fopen} can't
expect a matching \texttt{fclose}. External functions will be discussed further
in Chapter {chapref}. 

In short, there should be no state from which the host can't recover. No code
should, after being instrumented, be able to make the host environment
misbehave.

\subsection {Signal Handling}

Signals indicating errors should cause a plugin instance to shut down, and
indicate to the managing thread that this occurred. The host can then free
resources allocated to the plug-in. The host can then optionally reboot the
thread and plugin.

TODO: Describe that signal handler.
