\chapter {Function Calls}

Subroutines, or functions, are an important part of the structured-programming
paradigm, and they are centric to most modern programming languages. Without
enforcing great restrictions, a plugin will require calling other functions.

Most internal function calls should be safe. The plugin is not allowed to
rewrite its own code, so any call which explicitly calls a function residing
inside the plugin will finally be compiled to correctly calling instrumented
code which is considered safe. Incorrect indirect function calls could be
generated by calling incorrect function pointers. This could allow the plugin to
at least theoretically call functions which are linked to the program, but
shouldn't be accessible to the plugin. It could also result in the plugin
jumping to something which isn't a start location of a function and then attempt
to run arbitrary garbage. We also suspect that it could possibly allow the
plugin to bypass parts of the instrumented code by entering the function just
after validity checks should have been performed, but before the actual
instruction was performed.

External functions reside outside the protection domain, and running arbitrary
external functions with arbitrary parameters could very possibly allow the
plugin to execute a shell with the user's privileges and escalate its privileges
to run arbitrary code outside its protection domain. The ability to call
external function calls is however crucial to communicate with the host in a
simple manner.


\section {External Functions}

Apart from utility functions like algorithms and utility functions external
function calls constitutes an ability for the plugin to communicate with its
host. Without any external function calls (or inline assembly of these
functions, which we strongly suggest forbidding in Chapter[ref-instr]) no
communication back to the host environment can be initiated by the plugin.
Though plugins could technically be driven entirely with callbacks, unless the
plugins are limited to performing very specific tasks, we find this highly
impractical.

\subsection {Access Sets}

Access control to external functions for plugins doesn't have to be simply `all'
or `nothing'. Providing sets of external functions to plugins would allow an
user to select what it trusts a plugin to do; for instance, a plugin for
importing a certain file format could be allowed to read files, but not be
granted network access, while a RSS-reading plugin could be granted network
access, but not allowed to access local files. This granularity allows the user
to both be and feel more secure when running plugins, as they would need
explicit permission to use a certain set of resources.

The reader might be familiar with the Android operating system, where the
Android Permission Model[ref] restricts access to a few APIs such as camera
functions, storage and network/data connections. An user grants permissions to
these when installing an application: ``Prior to installation of any
application, the user is shown a clear message about the different permissions
the application is requesting. After install, the user is not prompted again to
confirm any permissions.'' Depending on the context where it's used, a similar
model could be desirable for plugins as well.

APM: \url{http://source.android.com/tech/security/index.html#the-android-permission-model-accessing-protected-apis}

Rack Extensions serve a very limited purpose, and our implementation did not
involve an any access sets. All of these plugins' access to external functions
is very limited as it is.

\subsection {Whitelist Policy}

External function calls need to be explicitly allowed based on a whitelist
policy. Blacklisting all disallowed functions seems a daunting task, and
potentially very error prone. If a plugin were to be linked against several
libraries not under control by the host, extensive research and effort would
have to be put forth against providing blacklists for every single one of them
with unintentional side effects. Another point towards infeasibility is that the
library version on the user's system might be a completely different one from
which the blacklist was developed against. New functions or changed function
behaviour could also have been introduced between versions, which could leave
the blacklist worthless.

Whitelisting however allows much easier introduction of a model following the
principle of least privilege. Apart from common standard utility functions and
other convenience functions, the host remains in tight control of what
potentially dangerous functions the plugin is allowed to call. For many
functions with side effect, a wrapper function or a modified implementation
needs to be introduced instead. All arguments needs to be sanity checked and
provide a graceful abort when the arguments are invalid, as external function
calls are executed outside the protection domain. This would require a blacklist
to basically blacklist all functions with potentially malicious side effects.

\subsection {Host Extension API}

TODO: Enough documentation of the Rack Extension API to desribe the point, but
not enough to leak trade secrets.

\subsection {Standard Libraries}



\section {Indirect Calls}

Instead of calling a function directly through a fixed name, a function pointer
can be dereferenced and then invoked like a regular function call. The
difference however is that a named function call will refer always refer to a
function, while a function pointer can be dereferenced to call an arbitrary
address, potentially not containing any function at all. If locations of
restricted functions inside linked libraries can somehow be determined, a
function pointer could be referring to a function which the plugin is not
permitted to call.

<LLVM asm for indirect function call, include getting addr of function>

Dereferencing and calling this function pointer would constitute a valid
function call to a forbidden function. The plugin would then have at least
partially broken out of its sandbox. Therefore any indirect calls have to be
validated prior to actual execution. Just like any memory accesses are to be
validated prior to \texttt{load}s and \texttt{store}s, etc.

Named function calls however do not have to be instrumented, they can directly
be permitted or rejected. If the call refers to a function inside the plugin or
a whitelisted external function, it's permitted, otherwise it's rejected.

<LLVM asm for direct function call>

<LLVM asm for direct function call to exec, forbidden>

To validate a function call, it's easiest to construct a lookup table, such as a
hash set, and fill it with all function addresses which the plugin is actually
allowed to call. This should consist of the plugin's own functions as well as
external functions which the plugin is permitted to use. Then prior to any
indirect function calls, validate that the function pointer actually points to a
valid address.

For typesafe matching, one lookup table per function type should be built and
specifically used when such a call is being dereferenced rather than one global.
We aren't aware of any ABIs or code generators which produce code where an
incorrect number or size of ingoing parameters actually passed could smash the
stack or otherwise affect a callee's ability to return properly. Such
environments would require typesafe matching to not mess up control flow.

In other cases an incorrect, or specifically smaller size of ingoing parameters
data would cause the subroutine to read garbage. This is however comparable to
maliciously passing garbage data, and as all external functions called have to
validate indata, this is already protected against.
