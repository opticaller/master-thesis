\chapter {Function Calls}

Subroutines, or functions, are an important part of the structured-programming
paradigm, and they are centric to most modern programming languages. Without
enforcing great restrictions, a plugin will require calling other functions.

Most internal function calls should be safe. The plugin is not allowed to
rewrite its own code, so any call which explicitly calls a function residing
inside the plugin will finally be compiled to correctly calling instrumented
code which is considered safe. Incorrect indirect function calls could be
generated by calling incorrect function pointers. This could allow the plugin to
at least theoretically call functions which are linked to the program, but
shouldn't be accessible to the plugin. It could also result in the plugin
jumping to something which isn't a start location of a function and then attempt
to run arbitrary garbage. We also suspect that it could possibly allow the
plugin to bypass parts of the instrumented code by entering the function just
after validity checks should have been performed, but before the actual
instruction was performed.

External functions reside outside the protection domain, and running arbitrary
external functions with arbitrary parameters could very possibly allow the
plugin to execute a shell with the user's privileges and escalate its privileges
to run arbitrary code outside its protection domain. The ability to call
external function calls is however crucial to communicate with the host in a
simple manner.


\section {External Functions}

Apart from utility functions like algorithms and utility functions external
function calls constitutes an ability for the plugin to communicate with its
host. Without any external function calls (or inline assembly of these
functions, which we strongly suggest forbidding in Chapter[ref-instr]) no
communication back to the host environment can be initiated by the plugin.
Though plugins could technically be driven entirely with callbacks, unless the
plugins are limited to performing very specific tasks, we find this highly
impractical.

\subsection {Access Sets}

Access control to external functions for plugins doesn't have to be simply `all'
or `nothing'. Providing sets of external functions to plugins would allow an
user to select what it trusts a plugin to do; for instance, a plugin for
importing a certain file format could be allowed to read files, but not be
granted network access, while a RSS-reading plugin could be granted network
access, but not allowed to access local files. This granularity allows the user
to both be and feel more secure when running plugins, as they would need
explicit permission to use a certain set of resources.

The reader might be familiar with the Android operating system, where the
Android Permission Model[ref] restricts access to a few APIs such as camera
functions, storage and network/data connections. An user grants permissions to
these when installing an application: ``Prior to installation of any
application, the user is shown a clear message about the different permissions
the application is requesting. After install, the user is not prompted again to
confirm any permissions.'' Depending on the context where it's used, a similar
model could be desirable for plugins as well.

APM: \url{http://source.android.com/tech/security/index.html#the-android-permission-model-accessing-protected-apis}

Rack Extensions serve a very limited purpose, and our implementation did not
involve an any access sets. All of these plugins' access to external functions
is very limited as it is.

\subsection {Whitelist Policy}

External function calls need to be explicitly allowed based on a whitelist
policy. Blacklisting all disallowed functions seems a daunting task, and
potentially very error prone. If a plugin were to be linked against several
libraries not under control by the host, extensive research and effort would
have to be put forth against providing blacklists for every single one of them
with unintentional side effects. Another point towards infeasibility is that the
library version on the user's system might be a completely different one from
which the blacklist was developed against. New functions or changed function
behaviour could also have been introduced between versions, which could leave
the blacklist worthless.

Whitelisting however allows much easier introduction of a model following the
principle of least privilege. Apart from common standard utility functions and
other convenience functions, the host remains in tight control of what
potentially dangerous functions the plugin is allowed to call. For many
functions with side effect, a wrapper function or a modified implementation
needs to be introduced instead. All arguments needs to be sanity checked and
provide a graceful abort when the arguments are invalid, as external function
calls are executed outside the protection domain. This would require a blacklist
to basically blacklist all functions with potentially malicious side effects.

\subsection {Standard Libraries}

Modern programming-language standard-libraries typically consists of algorithms,
such as sorting lists or math functions, data structures, such as lists, trees,
and maps and interaction with the host platform including input/output and
operating system calls. Typically, we only wish to restrict the latter. Standard
algorithms and data structures are only tools to make program development easier
and more reliable, as implementing all needed data structures and algorithms per
project from scratch can be hard, error-prone and time-consuming.

Pure functions which are defined on all input data, such as \texttt{sin} for
real numbers, can be whitelisted without hesitation. As they have no side
effects on any input, the plugin should be allowed to call them at its
convenience. Permissible functions not defined on the entire input domain need
to have their arguments validated. We expect this much of the undefined behavior
to be regarding accessing memory which the plugin, or program, does not own.
This checking addresses both crashes on accessing unallocated memory as well as
prevention of accesses by a plugin instance to memory owned by the host or other
plugin instances.

In unprotected languages, such as C or C++, many standard-library functions are
defined to have undefined behavior when fed with garbage data. \texttt{free} for
instance, has undefined behavior when trying to free some data which hasn't been
previously allocated by \texttt{malloc}, \texttt{calloc}, \texttt{realloc}. For
functions provided to the plugin, we want to provide an implementation where
this undefined behavior is redefined to abort the plugin.

For many functions, undefined behavior is introduced by function calls which
attempt to read or write to memory which it doesn't own. For such calls, 
statically compiling the function into the plugin before code instrumentation
occurs would address this issue, as the library code would also be instrumented.
It would however prevent a compiled LLVM module from being linked to a newer
version of the standard library function, for instance if a bug would have been
found.

External function calls that are trusted can also be more sparse with memory
checking. \texttt{memcpy}, for instance, can check the shadow memory for what's
actually being copied once, instead of once every read or store. If the
implementation were to copy $1024$ bytes individually, this means $1024$ checks
against shadow memory both for the source and destination. If the shadow memory
block size is large as well, say $512$ bytes, then an external function which
checks its indata could perform $2-3$ checks in the shadow memory for each
parameter instead of every memory access. (It should also validate that the
memory segments do not overlap, for which \texttt{memmove} should be used.)

\subsection {Host-Extension API}

The host-extension API should define a set of datatypes and functions to enable
intercommunication and possibly also provide domain-specific utility functions.
The former is required in order to request/recieve data and events from and to
the host. The latter provides functions and datatypes for reducing development
time and limiting bugs in the plugin, similar to language standard libraries.
Providing common functions, especially non-trivial ones, can greatly help the
overall quality of the host-platform plugins.

TODO: Enough documentation of the Rack Extension API to describe the point, but
not enough to leak trade secrets. Domain-specific functions could be fourier
transform, etc.


\section {Indirect Calls}

Instead of calling a function directly through a fixed name, a function pointer
can be dereferenced and then invoked like a regular function call. The
difference however is that a named function call will refer always refer to a
function, while a function pointer can be dereferenced to call an arbitrary
address, potentially not containing any function at all. If locations of
restricted functions inside linked libraries can somehow be determined, a
function pointer could be referring to a function which the plugin is not
permitted to call.

<LLVM asm for indirect function call, include getting addr of function>

Dereferencing and calling this function pointer would constitute a valid
function call to a forbidden function. The plugin would then have at least
partially broken out of its sandbox. Therefore any indirect calls have to be
validated prior to actual execution. Just like any memory accesses are to be
validated prior to \texttt{load}s and \texttt{store}s, etc.

Named function calls however do not have to be instrumented, they can directly
be permitted or rejected. If the call refers to a function inside the plugin or
a whitelisted external function, it's permitted, otherwise it's rejected.

<LLVM asm for direct function call>

<LLVM asm for direct function call to exec, forbidden>

To validate a function call, it's easiest to construct a lookup table, such as a
hash set, and fill it with all function addresses which the plugin is actually
allowed to call. This should consist of the plugin's own functions as well as
external functions which the plugin is permitted to use. Then prior to any
indirect function calls, validate that the function pointer actually points to a
valid address.

For typesafe matching, one lookup table per function type should be built and
specifically used when such a call is being dereferenced rather than one global.
We aren't aware of any ABIs or code generators which produce code where an
incorrect number or size of ingoing parameters actually passed could smash the
stack or otherwise affect a callee's ability to return properly. Such
environments would require typesafe matching to not mess up control flow.

In other cases an incorrect, or specifically smaller size of ingoing parameters
data would cause the subroutine to read garbage. This is however comparable to
maliciously passing garbage data, and as all external functions called have to
validate indata, this still has to be protected against.
