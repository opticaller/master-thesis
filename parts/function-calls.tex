\chapter {Function Calls}

Subroutines, or functions, are an important part of the structured-programming
paradigm, and they are centric to most modern programming languages. Without
enforcing great restrictions, a plugin will require calling other functions.

Most internal function calls should be safe. The plugin is not allowed to
rewrite its own code, so any call which explicitly calls a function residing
inside the plugin will finally be compiled to correctly calling instrumented
code which is considered safe. Incorrect indirect function calls could be
generated by calling incorrect function pointers. This could allow the plugin to
at least theoretically call functions which are linked to the program, but
shouldn't be accessible to the plugin. It could also result in the plugin
jumping to something which isn't a start location of a function and then attempt
to run arbitrary garbage. We also suspect that it could possibly allow the
plugin to bypass parts of the instrumented code by entering the function just
after validity checks should have been performed, but before the actual
instruction was performed.

External functions reside outside the protection domain, and running arbitrary
external functions with arbitrary parameters could very possibly allow the
plugin to execute a shell with the user's privileges and escalate its privileges
to run arbitrary code outside its protection domain. The ability to call
external function calls is however crucial to communicate with the host in a
simple manner.


\section {External Functions}

Apart from utility functions like algorithms and utility functions external
function calls constitutes an ability for the plugin to communicate with its
host. Without any external function calls (or inline assembly of these
functions, which we strongly suggest forbidding in Chapter[ref-instr]) no
communication back to the host environment can be initiated by the plugin.
Though plugins could technically be driven entirely with callbacks, unless the
plugins are limited to performing very specific tasks, we find this highly
impractical.

\subsection {Access Sets}

Access control to external functions for plugins doesn't have to be simply `all'
or `nothing'. Providing sets of external functions to plugins would allow an
user to select what it trusts a plugin to do; for instance, a plugin for
importing a certain file format could be allowed to read files, but not be
granted network access, while a RSS-reading plugin could be granted network
access, but not allowed to access local files. This granularity allows the user
to both be and feel more secure when running plugins, as they would need
explicit permission to use a certain set of resources.

The reader might be familiar with the Android operating system, where the
Android Permission Model[ref] restricts access to a few APIs such as camera
functions, storage and network/data connections. An user grants permissions to
these when installing an application: ``Prior to installation of any
application, the user is shown a clear message about the different permissions
the application is requesting. After install, the user is not prompted again to
confirm any permissions.'' Depending on the context where it's used, a similar
model could be desirable for plugins as well.

APM: \url{http://source.android.com/tech/security/index.html#the-android-permission-model-accessing-protected-apis}

Rack Extensions serve a very limited purpose, and our implementation did not
involve an any access sets. All of these plugins' access to external functions
is very limited as it is.

\subsection {Whitelist Policy}

External function calls need to be explicitly allowed based on a whitelist
policy. Blacklisting all disallowed functions seems a daunting task, and
potentially very error prone. If a plugin were to be linked against several
libraries not under control by the host, extensive research and effort would
have to be put forth against providing blacklists for every single one of them
with unintentional side effects. Another point towards infeasibility is that the
library version on the user's system might be a completely different one from
which the blacklist was developed against. New functions or changed function
behaviour could also have been introduced between versions, which could leave
the blacklist worthless.

Whitelisting however allows much easier introduction of a model following the
principle of least privilege. Apart from common standard utility functions and
other convenience functions, the host remains in tight control of what
potentially dangerous functions the plugin is allowed to call. For many
functions with side effect, a wrapper function or a modified implementation
needs to be introduced instead. All arguments needs to be sanity checked and
provide a graceful abort when the arguments are invalid, as external function
calls are executed outside the protection domain. This would require a blacklist
to basically blacklist all functions with potentially malicious side effects.

\subsection {Host Extension API}

\subsection {Standard Libraries}


\section {Function Pointers}


