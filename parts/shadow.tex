\chapter {Shadow Memory}

The shadow-memory model used by AddressSanitizer is very simple. A process'
entire memory space gets mapped to a fraction of it. For instance, with an $1:8$
compression, one continuous eigth of the addressable memory space gets reserved.
8 bytes of memory in the address space then correspond to one byte in this
map. The value of the byte encodes which of the 8 bytes are allocated. We make
the reasonable assumption that with this ratio $1:n$, $n$ is a power of two.
This, among other things, allows for faster instrumented code, as division by
$n$ is simply a bit-shift.

LLVM Bitcode is then instrumented so that, when allocating memory, the
corresponding fraction of addresses get marked as allocated in the map. The code
is also instrumented so that, before every instruction which operates on memory,
assertions are inserted to check their correctness before actually performing
them.

We propose a different encoding into the same shadow-map scheme. Whereas
AddressSanitizer encodes into this byte how many of the corresponding $n$ ($n = 8$
in this case) original bytes have been allocated, we propose encoding a
plugin-instance id instead. This way, we lose granularity, as a single $n$-byte
block is either ok to read or write, or not. But it allows us to perform a quick
check on whether the read is OK or not. The proposition is primarily a means of
protection and isolation, not a debugging tool.

For shadow-map specfics, we would like to point out AddressSantizer as the
authoritive implementation of this shadow-memory technique. We have been able to
reproduce the essential memory mapping in AddressSanitizer, with simliar
overhead, but their implementation in \texttt{clang} is way more mature. Their
paper[ref] also provide a good benchmark over performance hits imposed by the
technique.


\section {Shadow Compression}

The compression ratio between real memory and shadow memory directly affects
performance. If an aligned memory access is smaller than the compression ratio
then only a single check in the shadow is needed. This is crucial to be able to
provide access to basic types, such as \texttt{int}, \texttt{float} and
\texttt{double}, with acceptable overhead.

This single-level shadow map makes a $1:1$ mapping impossible, the shadow memory
would occupy the entire memory space and leave no room even for the running
code. $1:2$ mappings would reserve half of the address space and so forth. On
64-bit systems this is not a major issue, as the address space are many orders
of magnitude larger than the physical memory available. 32-bit systems however
have significantly limited address space.


\section {Memory Allocation}
Lightweight implementation, asan should be authoritative. Also has more
features.


\section {Memory Alignment}

Alignment + Access Size <= Compression Ratio => One check.

