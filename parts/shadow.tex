\chapter {Shadow Memory}

The shadow-memory model used by AddressSanitizer is very simple. A process'
entire memory space gets mapped to a fraction of it. For instance, with an $1:8$
compression, one continuous eigth of the addressable memory space gets reserved.
8 bytes of memory in the address space then correspond to one byte in this
map. The value of the byte encodes which of the 8 bytes are allocated. We'd like
to point out that for this thesis, the compression ratio between shadow memory
and main memory is a power of two. Though it may be technically possible to use
other alignments, we find no reason to explore this area, LLVM doesn't support
those alignments and instrumented code can be more efficient with powers of two.

AddressSanitizer instruments LLVM Bitcode so that, when allocating memory, the
corresponding fraction of addresses get marked as allocated in the shadow
memory. The code is also instrumented so that, before every instruction which
operates on memory, assertions are inserted to check their correctness before
actually performing them.

We propose a different encoding into the same shadow-map scheme. Whereas
AddressSanitizer encodes into this byte how many of the corresponding $n$
($n = 8$ in the previous case) original bytes have been allocated, we propose
encoding a plugin-instance id instead. This way, we lose granularity, as a
single $n$-byte block is either ok to read or write, or not. But it allows us to
perform a quick check on whether the read is OK or not. The proposition is
primarily a means of protection and isolation, not a debugging tool. Other
encodings are of course possible, as well as different tools.

For shadow-map specfics, we would like to point out AddressSantizer as the
authoritive implementation of this shadow-memory technique. We have been able to
reproduce the essential memory mapping in AddressSanitizer, with simliar
overhead, but their implementation in Clang is way more mature. Their
paper[ref] also provide a good benchmark over performance hits imposed by the
technique.


\section {Shadow Compression}

This single-level shadow map makes a $1:1$ mapping impossible, the shadow memory
would occupy the entire memory space and leave no room even for the running
code. $1:2$ mappings would reserve half of the address space and so forth. On
64-bit systems this is not a major issue, as the address space are many orders
of magnitude larger than the physical memory available. 32-bit systems however
have significantly limited address space.

The compression ratio between real memory and shadow memory directly affects
performance. If an aligned memory access is smaller than the compression ratio
then only a single check in the shadow is needed. This is crucial to be able to
provide access to basic types, such as \texttt{int}, \texttt{float} and
\texttt{double}, with acceptable overhead.

\subsection {Granularity}

As memory-access is granted based on memory blocks and not individual bytes,
memory must be handled in multiples of the compression ratio and be aligned to
the compression ratio boundary. For a $1:8$ ratio, that means all memory
allocation must occur in multiples of $8$ and its base address be a multiple of
$8$. This should, of course, be invisible to the plugin and sufficient memory
should be allocated to accomodate the requested allocation size aligned to the
proper boundary, as well as allocating any remaining space in the final block.


\section {Memory Allocation}

Let's fucking do it.


\section {Accesses across boundaries}


\section {Memory Alignment}

Alignment + Access Size <= Compression Ratio => One check.


