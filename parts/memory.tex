\chapter {Memory-Error Detection}

To protect the host and other plugins from having their heaps and/or stacks
modified, memory accesses between plugins and the host (and other programs) must
be checked in one way or another. Memory protection is a part of most modern
operating systems, and often has hardware support. This mechanism protects other
processes from incorrect memory accesses to their memory. Naturally, all memory
within a single process is shared by every thread of execution and all access
control implemented on a per-process process level [quote fuckyes?].
 
Inherently, this built-in protection offered by the operating system is not
applicable to a plugin model where memory is shared, such as in the thread-based
environment provided by Reason.


\section {Error-Detection Tools}

Fortunately a lot of erroneous-memory-usage behavior can be detected in user
space by using memory-error-detection tools. What they do essentially,
regardless of their implementation, is that when a program is run under it every
memory access becomes checked, and some kind of error is reported when incorrect
usage is detected.

The tools differ in what errors they detect and, how likely they're detected and
how they can be used. Some, such as Valgrind [link-to-paper-here], use runtime
techniques, such as dynamic recompilation and run binaries out of the box.
Others require that a program is recompiled in a certain way, such as specifying
additional compile-time flags. Inherently Valgrind can be used to detect memory
errors in a program to which the source code or build environment is not readily
available.

To be relevant to our problem however, errors need to be able to be detected at
the point of occurance, so that a plugin can abort when trying to do something
it's not allowed to do, and not after. The main difference between our solution
implies and what memory-error detectors provide out of the box is that the
error detectors work on a per-process basis, so a memory access is either OK or
not. We need a tool to detect whether a memory access is ok to perform for a
certain plugin instance.


\section {Shadow Map}

Common to the two tools which we summarize for background purpose is that they
use some sort of shadow map. That is, memory addresses mapped to a shadow value
which stores some data related to that range of addresses. The tools differ in
granularity. For instance, Valgrind detects errors on a bit level, while
AddressSanitizer detects errors on a per-byte level. The tools also replace or
hook memory-related functions including as \texttt{malloc} or \texttt{free} to
be able to track valid memory blocks.

For this thesis we'll consider a model in which the plugin instance is actually
encoded into this shadow map. This way we can detect not only if the memory is
ok to access by the entire program, but also if it can be accessed by the actual
plugin instance. This part is covered later in Chapter [REFERENCE HERE].

\subsection {Multi-Level Shadow Map}

Blah blah Valgrind more levels, ASan single level.


\section {Valgrind}

Overhead.

\subsection {Hooks}

\subsection {Characteristsics}

\subsection {Shadow Map}


\section {AddressSanitizer}

Stuff.

\subsection {Hooks}

\subsection {Characteristsics}

\subsection {Shadow Map}


\section {Per-Instance Address Spaces}

For a broader coverage of of the process and for flavor, we'd like to mention
another even more coarse-grained error-detection technique along with its flaws
which was considered before AddressSanitizer was recommended to us, and why the
solution was ultimately discarded even before we heard of AddressSanitizer.

Placing each plugin instance's stack and heap into its own continuous address
space allows for a single coarse-grained check against start and end address. By
allocating a continous segment as a power of two, this can be done efficiently
by masking the memory address to get its base address.

On 32-bit platforms virtual address space is limited however, and if there's no
good estimate on how much memory a plugin instance will use, the instance might
either have too much space allocated and the host's total address space
might run out when using too many extensions. Also, if the address space for an
extension runs out, it can't allocate more memory.

Worst of all is possibly the false sense of security this solution imposes when
attempting to protect against malicious plugins, or malicious input to them
through bugs. As the stack recides inside the instance's address space, it means
that all of the stack can be written to. However, the only part a a plugin
instance should be able to modify freely are local stack variables. Other data
such as return addresses need to be preserved in order to preserve control flow.

Failure to protect return addresses can lead to a buffer overflow causing the
plugin to return to uninstrumented code by smashing the stack. Existing software
vulnerable to such exploits are quite commonly found. The attack itself is well
explained by  [phrack-pseudonym, ref]. A program which \emph{intentionally}
exposes itself to such vulnerabilities or performs such an attack upon itself is
even easier to write.
