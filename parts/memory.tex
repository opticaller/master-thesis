\chapter {Memory-Error Detection}

To protect the host and other plugins from having their heaps and/or stacks
modified, memory accesses between plugins and the host (and other programs) must
be checked in one way or another. Memory protection is a part of most modern
operating systems, and often has hardware support. This mechanism protects other
processes from incorrect memory accesses to their memory. Naturally, all memory
within a single process is shared by every thread of execution and all access
control implemented on a per-process process level [quote fuckyes?].
 
Inherently, this built-in protection offered by the operating system is not
applicable to a plugin model where memory is shared, such as in the thread-based
environment provided by Reason.


\section {Error-Detection Tools}

Fortunately a lot of erroneous-memory-usage behavior can be detected in user
space by using memory-error-detection tools. What they do essentially,
regardless of their implementation, is that when a program is run under it every
memory access becomes checked, and some kind of error is reported when incorrect
usage is detected.

The tools differ in what errors they detect and, how likely they're detected and
how they can be used. Some, such as Valgrind [link-to-paper-here], use runtime
techniques, such as dynamic recompilation and run binaries out of the box.
Others require that a program is recompiled in a certain way, such as specifying
additional compile-time flags. Inherently Valgrind can be used to detect memory
errors in a program to which the source code or build environment is not readily
available.

To be relevant to our problem however, errors need to be able to be detected at
the point of occurance, so that a plugin can abort when trying to do something
it's not allowed to do, and not after. The main difference between our solution
implies and what memory-error detectors provide out of the box is that the
error detectors work on a per-process basis, so a memory access is either OK or
not. We need a tool to detect whether a memory access is ok to perform for a
certain plugin instance.


\section {Shadow Map}

Common to the two tools which we summarize for background purpose is that they
use some sort of shadow map. That is, memory addresses mapped to a shadow value
which stores some data related to that range of addresses. The tools differ in
granularity. For instance, Valgrind detects errors on a bit level, while
AddressSanitizer detects errors on a per-byte level. The tools also replace or
hook memory-related functions including as \texttt{malloc} or \texttt{free} to
be able to track valid memory blocks.

For this thesis we'll consider a model in which the plugin instance is actually
encoded into this shadow map. This way we can detect not only if the memory is
ok to access by the entire program, but also if it can be accessed by the actual
plugin instance. This part is covered later in Chapter [REFERENCE HERE].

\subsection {Multi-Level Shadow Map}

Blah blah Valgrind more levels, ASan single level.


\section {Valgrind}

Overhead.

\subsection {Hooks}

\subsection {Characteristsics}

\subsection {Shadow Map}


\section {AddressSanitizer}

Stuff.

\subsection {Hooks}

\subsection {Characteristsics}

\subsection {Shadow Map}


\section {Per-Instance Address Spaces}

Though not part of our final solution to memory protection, we'd like to mention
another even more coarse-grained error-detection technique considered before
finding AddressSanitizer, and why it was ultimately discarded even before
finding the AddressSanitizer pass and paper.

TODO: More text here. And fix the following paragraphs.. Still requires
instrumentation, asan better.

Placing each extension's stack and heap into its own continuous address space
allows for a single coarse-grained check against start and end address. On
32-bit platforms virtual address space is limited however, and if there's no
good estimate on how much memory an extension will use, the extension might
either have too much space allocated and the program's total address space
might run out when using too many extensions.

On the other hand, if the address space for an extension runs out, it can't
allocate more memory. Moving an extension's address space would however require
translating every pointer pointing to the block itself as well.

TODO: Downsides, doesn't protect stack, return addresses etc.
